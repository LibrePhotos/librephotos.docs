"use strict";(self.webpackChunklibrephotos_docs=self.webpackChunklibrephotos_docs||[]).push([[3244],{3905:(e,t,n)=>{n.d(t,{Zo:()=>m,kt:()=>c});var i=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},o=Object.keys(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var r=i.createContext({}),p=function(e){var t=i.useContext(r),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},m=function(e){var t=p(e.components);return i.createElement(r.Provider,{value:t},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},h=i.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,r=e.parentName,m=s(e,["components","mdxType","originalType","parentName"]),d=p(n),h=a,c=d["".concat(r,".").concat(h)]||d[h]||u[h]||o;return n?i.createElement(c,l(l({ref:t},m),{},{components:n})):i.createElement(c,l({ref:t},m))}));function c(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,l=new Array(o);l[0]=h;var s={};for(var r in t)hasOwnProperty.call(t,r)&&(s[r]=t[r]);s.originalType=e,s[d]="string"==typeof e?e:a,l[1]=s;for(var p=2;p<o;p++)l[p]=n[p];return i.createElement.apply(null,l)}return i.createElement.apply(null,n)}h.displayName="MDXCreateElement"},5884:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>r,contentTitle:()=>l,default:()=>u,frontMatter:()=>o,metadata:()=>s,toc:()=>p});var i=n(7462),a=(n(7294),n(3905));const o={title:"Missing Photos Implementation",excerpt:"Technical documentation for the missing photos feature",category:5},l=void 0,s={unversionedId:"development/contribution/backend/missing-photos",id:"development/contribution/backend/missing-photos",title:"Missing Photos Implementation",description:"Overview",source:"@site/docs/development/contribution/backend/missing-photos.md",sourceDirName:"development/contribution/backend",slug:"/development/contribution/backend/missing-photos",permalink:"/docs/development/contribution/backend/missing-photos",draft:!1,editUrl:"https://github.com/LibrePhotos/librephotos.docs/tree/master/docs/development/contribution/backend/missing-photos.md",tags:[],version:"current",frontMatter:{title:"Missing Photos Implementation",excerpt:"Technical documentation for the missing photos feature",category:5},sidebar:"userguide",previous:{title:" \ud83d\udcc1 Upload",permalink:"/docs/development/contribution/backend/upload"},next:{title:"\ud83d\udc0b Docker",permalink:"/docs/development/contribution/docker"}},r={},p=[{value:"Overview",id:"overview",level:2},{value:"Architecture",id:"architecture",level:2},{value:"Data Models",id:"data-models",level:3},{value:"File Model",id:"file-model",level:4},{value:"Photo Model",id:"photo-model",level:4},{value:"Detection Mechanism",id:"detection-mechanism",level:3},{value:"_check_files() Method",id:"_check_files-method",level:4},{value:"Jobs",id:"jobs",level:2},{value:"Scan Missing Photos Job",id:"scan-missing-photos-job",level:3},{value:"Delete Missing Photos Job",id:"delete-missing-photos-job",level:3},{value:"API Endpoints",id:"api-endpoints",level:2},{value:"Delete Missing Photos",id:"delete-missing-photos",level:3},{value:"Photo Statistics",id:"photo-statistics",level:3},{value:"Hash-Based Relinking",id:"hash-based-relinking",level:2},{value:"How It Works",id:"how-it-works",level:3},{value:"Relinking Process",id:"relinking-process",level:3},{value:"Frontend Integration",id:"frontend-integration",level:2},{value:"Photo Serializer",id:"photo-serializer",level:3},{value:"Video Error Handling",id:"video-error-handling",level:3},{value:"Future Implementation",id:"future-implementation",level:2},{value:"Real-Time File System Monitoring",id:"real-time-file-system-monitoring",level:3},{value:"Implementation Considerations",id:"implementation-considerations",level:3},{value:"Known Issues and TODOs",id:"known-issues-and-todos",level:2},{value:"Current TODOs",id:"current-todos",level:3},{value:"Edge Cases",id:"edge-cases",level:3},{value:"Code Organization",id:"code-organization",level:2},{value:"Key Files",id:"key-files",level:3},{value:"Testing Considerations",id:"testing-considerations",level:2},{value:"Related Documentation",id:"related-documentation",level:2}],m={toc:p},d="wrapper";function u(e){let{components:t,...n}=e;return(0,a.kt)(d,(0,i.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h2",{id:"overview"},"Overview"),(0,a.kt)("p",null,"The missing photos feature in LibrePhotos handles cases where photo files become unavailable on the file system while their metadata remains in the database. This document explains the architecture, implementation details, and how the system handles missing photos."),(0,a.kt)("h2",{id:"architecture"},"Architecture"),(0,a.kt)("h3",{id:"data-models"},"Data Models"),(0,a.kt)("h4",{id:"file-model"},"File Model"),(0,a.kt)("p",null,"Located in ",(0,a.kt)("inlineCode",{parentName:"p"},"librephotos/api/models/file.py"),", the ",(0,a.kt)("inlineCode",{parentName:"p"},"File")," model represents individual files on disk:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},'class File(models.Model):\n    hash = models.CharField(primary_key=True, max_length=64)\n    path = models.TextField(blank=True, default="")\n    type = models.PositiveIntegerField(choices=FILE_TYPES)\n    missing = models.BooleanField(default=False)  # Tracks if file is missing\n    embedded_media = models.ManyToManyField("File")\n')),(0,a.kt)("p",null,"Key fields:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"hash"),": MD5 hash of file content + user ID (primary key)"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"path"),": Full file system path"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"missing"),": Boolean flag indicating if the file cannot be found"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"type"),": File type (IMAGE, VIDEO, METADATA_FILE, RAW_FILE, UNKNOWN)")),(0,a.kt)("h4",{id:"photo-model"},"Photo Model"),(0,a.kt)("p",null,"Located in ",(0,a.kt)("inlineCode",{parentName:"p"},"librephotos/api/models/photo.py"),", the ",(0,a.kt)("inlineCode",{parentName:"p"},"Photo")," model has relationships to files:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},'class Photo(models.Model):\n    image_hash = models.CharField(primary_key=True, max_length=64)\n    files = models.ManyToManyField(File)  # All associated files\n    main_file = models.ForeignKey(\n        File,\n        related_name="main_photo",\n        on_delete=models.SET_NULL,\n        null=True,\n    )\n    # ... other fields\n')),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"A photo is considered missing when:")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"files=None")," (no associated files), OR"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"main_file=None")," (no primary file reference)")),(0,a.kt)("p",null,"Query for missing photos:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"missing_photos = Photo.objects.filter(\n    Q(owner=user) & Q(files=None) | Q(main_file=None)\n)\n")),(0,a.kt)("h3",{id:"detection-mechanism"},"Detection Mechanism"),(0,a.kt)("h4",{id:"_check_files-method"},"_check_files() Method"),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"Photo._check_files()")," method (lines 508-514 in ",(0,a.kt)("inlineCode",{parentName:"p"},"librephotos/api/models/photo.py"),") is the core detection mechanism:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"def _check_files(self):\n    for file in self.files.all():\n        if not file.path or not os.path.exists(file.path):\n            self.files.remove(file)  # Remove from photo's file list\n            file.missing = True       # Mark file as missing\n            file.save()\n    self.save()\n")),(0,a.kt)("p",null,"This method:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Iterates through all files associated with the photo"),(0,a.kt)("li",{parentName:"ol"},"Checks if the file path exists on the file system"),(0,a.kt)("li",{parentName:"ol"},"If missing, removes the file from the photo and sets ",(0,a.kt)("inlineCode",{parentName:"li"},"file.missing = True")),(0,a.kt)("li",{parentName:"ol"},"Saves changes to the database")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"When is this called?")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"During photo scans (",(0,a.kt)("inlineCode",{parentName:"li"},"scan_missing_photos")," job)"),(0,a.kt)("li",{parentName:"ul"},"When adding new files to existing photos"),(0,a.kt)("li",{parentName:"ul"},"After detecting duplicate photos during import")),(0,a.kt)("h2",{id:"jobs"},"Jobs"),(0,a.kt)("h3",{id:"scan-missing-photos-job"},"Scan Missing Photos Job"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Type"),": ",(0,a.kt)("inlineCode",{parentName:"p"},"JOB_SCAN_MISSING_PHOTOS")," (job type 14)"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Function"),": ",(0,a.kt)("inlineCode",{parentName:"p"},"scan_missing_photos(user, job_id)")," in ",(0,a.kt)("inlineCode",{parentName:"p"},"librephotos/api/directory_watcher.py:356-386")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Purpose"),": Checks all photos owned by a user to detect missing files"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Implementation"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},'def scan_missing_photos(user, job_id: UUID):\n    # Create or update job entry\n    lrj = LongRunningJob.objects.create(\n        started_by=user,\n        job_id=job_id,\n        job_type=LongRunningJob.JOB_SCAN_MISSING_PHOTOS,\n    )\n    \n    # Get all photos for user\n    existing_photos = Photo.objects.filter(owner=user.id).order_by("image_hash")\n    \n    # Process in batches of 5000 for memory efficiency\n    paginator = Paginator(existing_photos, 5000)\n    lrj.progress_target = paginator.num_pages\n    \n    for page in range(1, paginator.num_pages + 1):\n        for existing_photo in paginator.page(page).object_list:\n            existing_photo._check_files()  # Check each photo\'s files\n        update_scan_counter(job_id)\n')),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Key features"),":"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Processes photos in batches of 5,000 to manage memory"),(0,a.kt)("li",{parentName:"ul"},"Updates progress counter for UI feedback"),(0,a.kt)("li",{parentName:"ul"},"Automatically triggered after full scans if not scanning specific files")),(0,a.kt)("h3",{id:"delete-missing-photos-job"},"Delete Missing Photos Job"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Type"),": ",(0,a.kt)("inlineCode",{parentName:"p"},"JOB_DELETE_MISSING_PHOTOS")," (job type 5)"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Function"),": ",(0,a.kt)("inlineCode",{parentName:"p"},"delete_missing_photos(user, job_id)")," in ",(0,a.kt)("inlineCode",{parentName:"p"},"librephotos/api/autoalbum.py:188-232")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Purpose"),": Permanently removes missing photos and their associated data from the database"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Implementation"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"def delete_missing_photos(user, job_id):\n    # Find all photos with no files or no main file\n    missing_photos = Photo.objects.filter(\n        Q(owner=user) & Q(files=None) | Q(main_file=None)\n    )\n    \n    # Remove from all album types\n    for missing_photo in missing_photos:\n        album_dates = AlbumDate.objects.filter(photos=missing_photo)\n        for album_date in album_dates:\n            album_date.photos.remove(missing_photo)\n        \n        album_things = AlbumThing.objects.filter(photos=missing_photo)\n        for album_thing in album_things:\n            album_thing.photos.remove(missing_photo)\n        \n        album_places = AlbumPlace.objects.filter(photos=missing_photo)\n        for album_place in album_places:\n            album_place.photos.remove(missing_photo)\n        \n        album_users = AlbumUser.objects.filter(photos=missing_photo)\n        for album_user in album_users:\n            album_user.photos.remove(missing_photo)\n        \n        # Delete associated faces\n        faces = Face.objects.filter(photo=missing_photo)\n        faces.delete()\n    \n    # Delete the photos\n    missing_photos.delete()\n    \n    # Delete missing file records\n    missing_files = File.objects.filter(Q(hash__endswith=user) & Q(missing=True))\n    missing_files.delete()\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"What gets deleted"),":"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Photo records from database"),(0,a.kt)("li",{parentName:"ul"},"File records marked as missing"),(0,a.kt)("li",{parentName:"ul"},"Associations with date-based albums"),(0,a.kt)("li",{parentName:"ul"},"Associations with thing-based albums"),(0,a.kt)("li",{parentName:"ul"},"Associations with place-based albums"),(0,a.kt)("li",{parentName:"ul"},"Associations with user-created albums"),(0,a.kt)("li",{parentName:"ul"},"Face detections linked to the photos")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"What doesn't get deleted (TODO)"),":"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},'Thumbnail files (line 221 notes: "To-Do: Remove thumbnails")')),(0,a.kt)("h2",{id:"api-endpoints"},"API Endpoints"),(0,a.kt)("h3",{id:"delete-missing-photos"},"Delete Missing Photos"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Endpoint"),": ",(0,a.kt)("inlineCode",{parentName:"p"},"POST /api/deletemissingphotos")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Implementation"),": ",(0,a.kt)("inlineCode",{parentName:"p"},"DeleteMissingPhotosView")," in ",(0,a.kt)("inlineCode",{parentName:"p"},"librephotos/api/views/views.py:433-451")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},'class DeleteMissingPhotosView(APIView):\n    def post(self, request, format=None):\n        try:\n            job_id = uuid.uuid4()\n            delete_missing_photos(request.user, job_id)\n            return Response({"status": True, "job_id": job_id})\n        except BaseException:\n            logger.exception("An Error occurred")\n            return Response({"status": False})\n')),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Response"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "status": true,\n  "job_id": "550e8400-e29b-41d4-a716-446655440000"\n}\n')),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Note"),": Also supports GET method (deprecated) for backward compatibility."),(0,a.kt)("h3",{id:"photo-statistics"},"Photo Statistics"),(0,a.kt)("p",null,"Missing photo count is included in the user statistics API response."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Calculation"),": ",(0,a.kt)("inlineCode",{parentName:"p"},"get_count_stats(user)")," in ",(0,a.kt)("inlineCode",{parentName:"p"},"librephotos/api/stats.py:382-384")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"num_missing_photos = Photo.objects.filter(\n    Q(owner=user) & Q(files=None) | Q(main_file=None)\n).count()\n")),(0,a.kt)("p",null,"Returned in stats response as:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "num_photos": 1234,\n  "num_missing_photos": 5,\n  // ... other stats\n}\n')),(0,a.kt)("h2",{id:"hash-based-relinking"},"Hash-Based Relinking"),(0,a.kt)("h3",{id:"how-it-works"},"How It Works"),(0,a.kt)("p",null,"When files reappear in the scanned directories (even with different names or paths), LibrePhotos can automatically relink them using hash-based matching."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Hash Calculation"),": ",(0,a.kt)("inlineCode",{parentName:"p"},"calculate_hash(user, path)")," in ",(0,a.kt)("inlineCode",{parentName:"p"},"librephotos/api/models/file.py:136-145")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},'def calculate_hash(user, path):\n    hash_md5 = hashlib.md5()\n    with open(path, "rb") as f:\n        for chunk in iter(lambda: f.read(BUFFER_SIZE), b""):\n            hash_md5.update(chunk)\n    return hash_md5.hexdigest() + str(user.id)\n')),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Key points"),":"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Hash is MD5 of file content + user ID"),(0,a.kt)("li",{parentName:"ul"},"User ID ensures photos are scoped to individual users in multi-user setups"),(0,a.kt)("li",{parentName:"ul"},"Buffer size of 65536 bytes for optimal performance")),(0,a.kt)("h3",{id:"relinking-process"},"Relinking Process"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Function"),": ",(0,a.kt)("inlineCode",{parentName:"p"},"create_new_image(user, path)")," in ",(0,a.kt)("inlineCode",{parentName:"p"},"librephotos/api/directory_watcher.py:62-136")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"def create_new_image(user, path) -> Photo | None:\n    # Calculate hash for the file\n    hash = calculate_hash(user, path)\n    \n    # Check if photo with this hash already exists\n    photos: QuerySet[Photo] = Photo.objects.filter(image_hash=hash, owner=user)\n    \n    if not photos.exists():\n        # Create new photo\n        photo = Photo()\n        photo.image_hash = hash\n        # ... initialize photo\n    else:\n        # Photo exists - add this file to it (relinking)\n        file = File.create(path, user)\n        photo = photos.first()\n        photo.files.add(file)\n        \n        # Restore if previously marked as removed\n        if photo.removed:\n            photo.removed = False\n            photo.in_trashcan = False\n        \n        photo.save()\n        photo._check_files()  # Verify all files still exist\n        \n    return photo\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Relinking behavior"),":"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Calculate hash of discovered file"),(0,a.kt)("li",{parentName:"ol"},"Query for existing photos with same hash"),(0,a.kt)("li",{parentName:"ol"},"If found, add new file to existing photo"),(0,a.kt)("li",{parentName:"ol"},"Restore photo if it was marked as removed"),(0,a.kt)("li",{parentName:"ol"},"Run ",(0,a.kt)("inlineCode",{parentName:"li"},"_check_files()")," to clean up any still-missing files")),(0,a.kt)("h2",{id:"frontend-integration"},"Frontend Integration"),(0,a.kt)("h3",{id:"photo-serializer"},"Photo Serializer"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"File"),": ",(0,a.kt)("inlineCode",{parentName:"p"},"librephotos/api/serializers/photos.py:348")),(0,a.kt)("p",null,'The serializer includes a "Missing" label for photos without files:'),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},'def get_image_path(self, obj) -> list[str]:\n    if not obj.files or obj.files.count() == 0:\n        return ["Missing"]\n    return [file.path for file in obj.files.all()]\n')),(0,a.kt)("p",null,"This ensures the frontend can display appropriate UI for missing photos."),(0,a.kt)("h3",{id:"video-error-handling"},"Video Error Handling"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"File"),": ",(0,a.kt)("inlineCode",{parentName:"p"},"librephotos-frontend/src/components/lightbox/MediaDisplay.tsx:64-69")),(0,a.kt)("p",null,"The frontend displays an error alert when video files are missing:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-tsx"},'if (videoError) {\n  return (\n    <Alert color="red" title="Video Not Found">\n      <Text>The video file could not be found or is no longer available.</Text>\n    </Alert>\n  );\n}\n')),(0,a.kt)("h2",{id:"future-implementation"},"Future Implementation"),(0,a.kt)("h3",{id:"real-time-file-system-monitoring"},"Real-Time File System Monitoring"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Goal"),": Eliminate most missing photo cases through proactive file tracking"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Planned features"),":"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"File System Watchers")),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"Implement inotify (Linux), FSEvents (macOS), or watchdog library"),(0,a.kt)("li",{parentName:"ul"},"Monitor scanned directories for file changes in real-time"),(0,a.kt)("li",{parentName:"ul"},"Trigger immediate updates instead of waiting for manual scans"))),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"Move/Rename Detection")),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"Detect when files are moved within scanned directories"),(0,a.kt)("li",{parentName:"ul"},"Automatically update file paths in database"),(0,a.kt)("li",{parentName:"ul"},"Preserve all metadata, ratings, and associations"))),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"Immediate Relinking")),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"Hash-based matching happens immediately when files appear"),(0,a.kt)("li",{parentName:"ul"},"No manual scan required"),(0,a.kt)("li",{parentName:"ul"},'Significantly reduced "missing photo" window'))),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"Benefits")),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"Near-instant UI updates when files change"),(0,a.kt)("li",{parentName:"ul"},"Reduced database queries (no periodic scanning)"),(0,a.kt)("li",{parentName:"ul"},"Better user experience with fewer missing photos"),(0,a.kt)("li",{parentName:"ul"},"Lower system resource usage")))),(0,a.kt)("h3",{id:"implementation-considerations"},"Implementation Considerations"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Performance impact of continuous monitoring"),(0,a.kt)("li",{parentName:"ul"},"Handling large directory trees efficiently"),(0,a.kt)("li",{parentName:"ul"},"Network storage compatibility (NAS, SMB, NFS)"),(0,a.kt)("li",{parentName:"ul"},"Docker container file system event propagation"),(0,a.kt)("li",{parentName:"ul"},"Graceful degradation if monitoring unavailable")),(0,a.kt)("h2",{id:"known-issues-and-todos"},"Known Issues and TODOs"),(0,a.kt)("h3",{id:"current-todos"},"Current TODOs"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"Remove thumbnails")," (line 221 in ",(0,a.kt)("inlineCode",{parentName:"p"},"autoalbum.py"),")"),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"When deleting missing photos, thumbnail files are not removed"),(0,a.kt)("li",{parentName:"ul"},"Thumbnails remain in ",(0,a.kt)("inlineCode",{parentName:"li"},"data/thumbnails/")," directory"),(0,a.kt)("li",{parentName:"ul"},"Should be cleaned up to free disk space"))),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"Move delete_missing_photos function")," (line 187 in ",(0,a.kt)("inlineCode",{parentName:"p"},"autoalbum.py"),")"),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"Currently in ",(0,a.kt)("inlineCode",{parentName:"li"},"autoalbum.py")," but doesn't belong there"),(0,a.kt)("li",{parentName:"ul"},"Should be moved to appropriate module (e.g., ",(0,a.kt)("inlineCode",{parentName:"li"},"photo_operations.py")," or similar)"),(0,a.kt)("li",{parentName:"ul"},'Comment says: "To-Do: This does not belong here"')))),(0,a.kt)("h3",{id:"edge-cases"},"Edge Cases"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"Symbolic links"),": May not be handled correctly in all cases"),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"Network storage timeouts"),": Slow network storage may cause false positives"),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"Permissions"),": Permission changes could make files appear missing"),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"Race conditions"),": Files changed during scan may cause inconsistencies")),(0,a.kt)("h2",{id:"code-organization"},"Code Organization"),(0,a.kt)("h3",{id:"key-files"},"Key Files"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"Models"),":"),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"librephotos/api/models/file.py")," - File model with missing flag"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"librephotos/api/models/photo.py")," - Photo model and ",(0,a.kt)("inlineCode",{parentName:"li"},"_check_files()")," method"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"librephotos/api/models/long_running_job.py")," - Job type definitions"))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"Business Logic"),":"),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"librephotos/api/directory_watcher.py")," - Scanning and relinking logic"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"librephotos/api/autoalbum.py")," - Delete missing photos function"))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"API Views"),":"),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"librephotos/api/views/views.py")," - Delete missing photos endpoint"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"librephotos/api/views/photos.py")," - Photo operations"))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"Statistics"),":"),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"librephotos/api/stats.py")," - Count calculations including missing photos"))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"Serializers"),":"),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"librephotos/api/serializers/photos.py"),' - Photo serialization with "Missing" label')))),(0,a.kt)("h2",{id:"testing-considerations"},"Testing Considerations"),(0,a.kt)("p",null,"When testing missing photos functionality:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"Setup"),": Create photos with valid files"),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"Trigger"),": Remove files from file system (outside LibrePhotos)"),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"Scan"),": Run ",(0,a.kt)("inlineCode",{parentName:"li"},"scan_missing_photos")," job"),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"Verify"),": Check that photos marked as missing"),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"Restore"),": Add files back and rescan"),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"Verify relinking"),": Ensure photos automatically relink"),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"Delete"),": Test permanent deletion with ",(0,a.kt)("inlineCode",{parentName:"li"},"delete_missing_photos"))),(0,a.kt)("h2",{id:"related-documentation"},"Related Documentation"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"/docs/development/contribution/backend/photo-list"},"Photo List Implementation")," - Understanding photo queries and display"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"/docs/development/contribution/backend/thumbnails"},"Thumbnails")," - How thumbnails are generated and stored"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"/docs/development/contribution/backend/upload"},"Upload System")," - File handling during uploads")))}u.isMDXComponent=!0}}]);